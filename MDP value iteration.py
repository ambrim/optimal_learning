# -*- coding: utf-8 -*-
"""ORF418 HW5 MDP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P8qbp429bw3SoblHxYp5OAfVNVNiYMfJ

# Chap 5. MDP. Value iteration algorithm for the problem "Journey on a grid"
"""

import numpy as np
from scipy import linalg as la
from tabulate import tabulate

"""Computing the expected value of going north"""

def go_north(point, function, Pr, sp):
    size = np.shape(function)
    rows, cols = size
    i,j = point
    cost = function[i-1][j];
    if j!=(cols-1) and (i,j+1) not in Pr:
        if j!=0 and (i,j-1) not in Pr:
            return sp*cost+((1-sp)/2)*(function[i][j-1]+function[i][j+1])
        else:
            return sp*cost+(1-sp)*function[i][j+1]
    else:
        if j!=0 and (i,j-1) not in Pr:
            return sp*cost+(1-sp)*function[i][j-1]
        else:
            return cost

"""Same for other directions"""

# Going south
def go_south(point, function, Pr, sp):
    size = np.shape(function)
    rows, cols = size
    i,j = point
    cost = function[i+1][j]
    # To be completed
    if j!=(cols-1) and (i,j+1) not in Pr:
        if j!=0 and (i,j-1) not in Pr:
            return sp*cost+((1-sp)/2)*(function[i][j-1]+function[i][j+1])
        else:
            return sp*cost+(1-sp)*function[i][j+1]
    elif j!=0 and (i,j-1) not in Pr:
            return sp*cost+(1-sp)*function[i][j-1]
    else: return cost

# Going east
def go_east(point, function, Pr, sp):
    size = np.shape(function)
    rows, cols = size
    i,j = point
    cost = function[i][j+1]
    # To be completed
    if i!=(rows-1) and (i+1,j) not in Pr:
        if i!=0 and (i-1,j) not in Pr:
            return sp*cost+((1-sp)/2)*(function[i-1][j]+function[i+1][j])
        else:
            return sp*cost+(1-sp)*function[i+1][j]
    elif i!=0 and (i-1,j) not in Pr:
            return sp*cost+(1-sp)*function[i-1][j]
    else: return cost

# Going west
def go_west(point, function, Pr, sp):
    size = np.shape(function)
    rows, cols = size
    i,j = point
    cost = function[i][j-1]
    # To be completed
    if i!=(rows-1) and (i+1,j) not in Pr:
        if i!=0 and (i-1,j) not in Pr:
            return sp*cost+((1-sp)/2)*(function[i-1][j]+function[i+1][j])
        else:
            return sp*cost+(1-sp)*function[i+1][j]
    elif i!=0 and (i-1,j) not in Pr:
            return sp*cost+(1-sp)*function[i-1][j]
    else: return cost

"""Computing the minimum expected value and the minimizer for every point in the grid"""

def find_optimal(E, A):
    # To be completed
    a_opt = A[E.index(min(E))]
    e_min = min(E)
    return e_min, a_opt

def max_exp(Tr, function, Pr, sp):
    size = np.shape(function)
    rows, cols = size
    min_e    = np.array(np.zeros(size))
    policy   = np.empty(size, dtype='str')
    
    for i in range(rows):       
        for j in range(cols):
            point = (i,j)
            # setting value to zero at terminal point
            if point in Tr: 
                min_e[i][j] = 0
                policy[i][j] = 'T'
            else:
                E=[]
                A_effective=[]
                
                # going north to (i-1,j) if it is allowed
                if i != 0 and (i-1,j) not in Pr:
                    A_effective.append('N')
                    E.append(go_north(point, function, Pr, sp)) 
                
                # To be completed ########################
                # going south to (i+1,j) if it is allowed
                if i != rows-1 and (i+1,j) not in Pr:
                    A_effective.append('S')
                    # E is the value function of going south
                    E.append(go_south(point, function, Pr, sp))
                # going west to (i,j-1) if it is allowed
                if j != 0 and (i,j-1) not in Pr:
                    A_effective.append('W')
                    E.append(go_west(point, function, Pr, sp))
                # going east to (i,j+1) if it is allowed
                if j != cols-1 and (i,j+1) not in Pr:
                    A_effective.append('E')
                    E.append(go_east(point, function, Pr, sp))
                min_e[i][j], policy[i][j] = find_optimal(E, A_effective)

    return min_e , policy

"""Recursive algorithm starting from some initialisation v0"""

def iterate_WC(Tr, Pr, cost, sp, rho, num):
    # num is the maximum number of iterations
    tol = np.finfo(float).eps # Tolerance level (machine precision)
    size = np.shape(cost)
    v0=np.zeros(size)

    # Iteration of the Value Iteration algorithm
    for k in range(num):
        enext, _ = max_exp(Tr, v0, Pr, sp)
        vnext = C + rho*enext
        if la.norm(vnext-v0) < tol: 
            print("Converges after %d iterations"%k)
            break
        else:
            v0=vnext 
    
    _, policy = max_exp(Tr, vnext, Pr, sp)
    return vnext, policy

"""Print the results as "nice" tables"""

def print_tabular(v,f,cost,Pr):
    # Changing the values at Forbidden points
    n, m = v.shape
    for i in range(n):
        for j in range(m):
            if (i,j) in Pr:
                v[i][j]=np.infty
                cost[i][j]=np.infty
                f[i][j] ='X'
    print('Given Cost Values')
    print(tabulate(cost, headers=[], tablefmt="grid"))
    print()
    print('Computed Minimum Values')
    print(tabulate(v, headers=[], tablefmt="grid"))
    print()
    print('Optimal actions')
    print(tabulate(f, headers=[], tablefmt="grid"))
    print()

"""**Answers to 6, 7, 8:**

Separated by code blocks
"""

# Checking Q4 ##########
p   = 0.9
rho = 1
C   = [[3, 5],
       [1, 0]]
T   = [(1,1)]
Pr  = []

v, f = iterate_WC(T, Pr, C, p, rho, 10**3)
print_tabular(v, f, C, Pr)

# Q5 ###################
p   = 0.9
rho = 1
C   = [[2, 1, 1], 
       [1, 5, 0]]
T   = [(1, 2)]
Pr  = []

v, f = iterate_WC(T, Pr, C, p, rho, 10**3)
print_tabular(v, f, C, Pr)

# Q6 ###################
p   = 0.9
rho = 1
C   = [[3, 1],
       [5, 0]]
T   = [(1,1)]
Pr  = []

v, f = iterate_WC(T, Pr, C, p, rho, 10**3)
print_tabular(v, f, C, Pr) 

print('''Compared with the results from Q4, we see that the cost and minimum 
value matrices are transposed, but with the same values. Note that the optimal 
action sequence still avoids the block with cost 5, since the alternative 
gives a lower cost, thus the optimal route is transposed as well, as 
reflected by the new action sequence (S becomes E for the top left square).''')

# Q7 ###################
p   = 0.9
rho = 1
C   = [[2, 1], 
       [1, 5],
       [1, 0]]
T   = [(2,1)]
Pr  = []

v, f = iterate_WC(T, Pr, C, p, rho, 10**3)
print_tabular(v, f, C, Pr) 

print('''Using the connection observed above, the minimum values for Q5 are the
same as the minimum values here, but transposed (since costs are transposed).
The optimal route is tranposed as well, as shown below: ''')

# Q8 ###################
p   = 0.9
rho = 1
C   = [[1, 1, 1, 1, 1] , [1, 1, 1, 100, 10],
       [1, 10, 0, 1, 1], [2, 2, 1, 1, 1], [2, 2, 1, 1, 1]]
T   = [(2,2)]
Pr  = []

v, f = iterate_WC(T, Pr, C, p, rho, 10**3)
print_tabular(v, f, C, Pr) 
print('''Note that in this case, it may be optimal to take a more convoluted
path to avoid the 0.05 probability of incurring +100 cost. ''')